Yul vs Solidity Contract Comparison
by jtriley.eth

https://medium.com/@jtriley15/yul-vs-solidity-contract-comparison-2b6d9e9dc833

In this article, I will be writing and breaking down a simple smart contract in both Solidity and Yul for a side-by-side comparison on the syntax. A beginner to intermediate understanding of Solidity and the Ethereum Virtual Machine (EVM) is assumed for the scope of the article.
Overview

For the scope of this article, I will be using Remix IDE, and will provide some gists with the full source code. While I will explain each of the opcodes used in this article, it would be a good idea to read the documentation and keep an opcode table on hand.
Yul

Yul is a thin layer of abstraction on the EVM opcode language that can be used in a standalone Yul contract file, or in a Solidity contract file via an assembly block.

function readWithYul() public view returns (uint256 data) {
    assembly {
        data := sload(0)
    }
}

The assignment operator for Yul is := as opposed to = in Solidity. Each opcode takes a unique set of parameters, which can be found via an opcode table (linked below).

Yul is not an executable binary, however, meaning it still needs to be compiled to run in the EVM. At the time of writing, Yul can be compiled to both the EVM opcode language and eWASM, a proposed opcode language for ETH 2.0 in the coming months.
Bytes > Types

It’s important to understand the EVM uses 32 byte words, and Solidity types are just an abstraction on top of those words. The Yul dialect defines only a u256 type, representing an unsigned 256 bit integer, or a 32 byte word.
It’s just bytes all the way down.
Function Selectors

A function is accessible by its selector. When you call a function on a contract via a blockchain client library like web3.js or ethers.js, a few things happen under the hood.

First, the function signature is generated. This is a string containing the function name followed by the parameter types, comma separated, wrapped in parenthesis.

// function declaration
function myFunc(uint256 param1, address param2) {}// function signature
string signature = "myFunc(uint256,address)"

Next, the function signature is hashed with keccak256 and clipped to the leftmost 4 bytes to produce the function selector.

// selector = 0x67adc20f
bytes4 selector = bytes4(keccak256("myFunc(uint256,address)"));

So if you were to call this function, passing the number 42 as the first argument, and an address, 0x5B38…c4 (shortened), as the second argument, the encoded payload might look like

0x67adc20f0000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4

Which if we pick it apart, we’ll see:

// hexadecimal prefix
0x// selector for myFunc(uint256,address)
67adc20f// number 42, padded to 32 bytes
0000000000000000000000000000000000000000000000000000000000000002a// 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 padded to 32 bytes
0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4

This is going to be important when accessing different functions later.
Calldata, Stack, Memory, and Storage

Next, you should understand calldata, the stack, memory, and storage.

When a function is called, as it is above, that encoded payload is the calldata. You can access calldata size with calldatasize(), you can read 32 bytes of the calldata with calldataload(offset) where the offset is the starting position in the calldata to read, and you can copy the calldata to memory with calldatacopy(destOffset, offset, size) where the destOffset is the starting position in memory to copy to, offset is the starting position in the calldata to copy, and size is the number of bytes in the calldata to copy.

The stack holds 32 byte words, has a stack depth of 1024, and functions like any other stack. You can push, pop, swap, and perform arithmetic, as you would on any other stack. Yul handles a lot of this for you, so interacting with the stack directly via the push and pop opcodes is beyond the scope of this article.

The memory is linear, and can store data temporarily, but is cleared between message calls. Writing to memory can be done in increments of 8 bits using mstore8(offset, value) where offset is the starting location in memory and value is the 8 bit value to store, or in increments of 256 bits using mstore(offset, value), where offset is the starting location in memory and value is the 256 bit value to store. Reading from memory can be done with mload(offset) where offset is the starting location in memory. Reading from memory will always return 256 bits starting at the offset. Note the gas cost of interacting with memory scales quadratically with the size of the data stored in memory.

Storage is persistent between function calls, and is also referred to as the state. The storage consists of key/value pairs where both the key and value are both 256 bit words. Writing to state is done with sstore(key, value) where the key is the location in storage, and the value is the 256 bit value to store at the given key’s position. Reading from storage can be done with sload(key) where the key is the position at which the desired value is stored. Reading and writing to storage is the most expensive in terms of gas. Further details can be found in the EVM opcodes link below.
Links

Interactive opcode table:
EVM Codes
An interactive reference to Ethereum Virtual Machine Opcodes

www.evm.codes

Yul Docs:
Yul - Solidity 0.8.11 documentation
Yul (previously also called JULIA or IULIA) is an intermediate language that can be compiled to bytecode for different…

docs.soliditylang.org
The Contracts

For the scope of this article, we will write a contract that has one state variable, a read function, a write function, a fallback function, and a single event that gets emitted when the state variable is written.
SolidityContract.sol

For Solidity developers, this will be mostly self explanatory, but we will briefly review the code for clarity. As usual, here is the full source first, and we’ll break it down below.

First up, we have an event definition, MyNumberSet. This is to be emitted only when the state variable _myNumber gets updated. It will log the setter, old number, and new number.

Next, we have the internal state variable _myNumber which is an unsigned 256 bit integer.

Next is a read() function that will read _myNumber from state and return it to the caller.

Next, there is a set(uint256) function that takes an unsigned 256 bit integer as a parameter, assigns it as the new _myNumber value, and emits the MyNumberSet event, logging all of the relevant information.

Finally, we have a fallback function. The fallback function gets hit when a function is called on this contract that doesn’t actually exist. Our fallback function takes a parameter of type bytes calldata as usual, but we don’t assign a name to it in this case because we’re not going to use it, we’re just going to return a single bytes memory variable. In this case, we’re going to just return the number 42 in the event of the fallback being called.

Juicy.
YulContract.sol

/// @title Simple read-write contract written in Yul
/// @author jtriley.eth
/// @notice This is designed to be functionally identical to ./SolidityContract.sol
/// This is for educational purposes only, do not use in production.
object "YulContract" {
    code {
        /// @dev Deploys the contract
        datacopy(0, dataoffset("runtime"), datasize("runtime"))
        return (0, datasize("runtime"))
    }
    object "runtime" {
        code {
            // ----- ----- -----
            // VALUE CHECKER
            // ----- ----- -----
            /// @dev reverts if msg.value is greater than 0
            if iszero(iszero(callvalue())) {
                revert(0, 0)
            }

            // ----- ----- -----
            // SELECTOR SWITCH
            // ----- ----- -----
            /// @dev switch evaluating the function selector
            switch extractSelector()
            
            // bytes4(keccak256("read()"))
            case 0x57de26a4 {
                returnUint(read())
            }

            // bytes4(keccak256("set(uint256)"))
            case 0x60fe47b1 {
                set(extractUint(0))
            }

            // fallback()
            default {
                returnUint(42)
            }

            // ----- ----- -----
            // EXTERNAL
            // ----- ----- -----
            /// @notice Reads myNumber from state slot 0
            /// @return _myNumber The number read from storage
            function read() -> _myNumber {
                _myNumber := sload(myNumberSlot())
            }

            /// @notice Writes new number to state
            /// @dev emits MyNumberSet
            /// @param newNumber to write to storage
            function set(newNumber) {
                let oldNumber := sload(myNumberSlot())
                sstore(myNumberSlot(), newNumber)
                emitMyNumberSet(caller(), oldNumber, newNumber)
            }

            // ----- ----- -----
            // CALLDATA DECODERS
            // ----- ----- -----

            /// @dev extracts 4 byte selector from calldata
            function extractSelector() -> _selector {
                _selector := shr(0x28, calldataload(0))
            }

            /// @dev extracts uint256 from calldata
            /// offset = parameter index, starting at zero
            function extractUint(offset) -> _value {
                let position := add(4, mul(offset, 0x20))
                if lt(calldatasize(), add(position, 0x20)) {
                    revert(0, 0)
                }
                _value := calldataload(position)
            }

            // ----- ----- -----
            // CALLDATA ENCODER
            // ----- ----- -----
            /// @dev Stores parameter in memory, calls return on first
            /// 32 bytes of memory
            function returnUint(value) {
                mstore(0,  value)
                return(0, 0x20)
            }

            // ----- ----- -----
            // STORAGE LAYOUT
            // ----- ----- -----
            /// @dev Returns storage slot for myNumber
            function myNumberSlot() -> _slot {
                _slot := 0
            }

            // ----- ----- -----
            // EVENT EMITTER
            // ----- ----- -----
            /// @notice emits MyNumberSet
            /// @dev Uses log2 with signatureHash and setter (indexed) as topics
            /// @param setter Indexed address of number setter
            /// @param oldNumber Not indexed old number
            /// @param newNumber Not indexed new number
            function emitMyNumberSet(setter, oldNumber, newNumber) {
                // keccak256("MyNumberSet(address,uint256,uin256)");
                let signatureHash := 0x29ad1af1374ae5de3c5b3f510eb08a7d10028e9dfe5aff6570c701c4177c76cb
                mstore(0, oldNumber)
                mstore(0x20, newNumber)
                log2(0, 0x40, signatureHash, setter)
            }
        }
    }
}

This gets complicated, and I won’t be able to simply break things down in such a linear way, given the amount of helper functions. Nonetheless, here is the full source, and a line-by-line breakdown will follow.

WHEW.

Okay, first up, let’s look at the highest level. We have an object declaration with a string literal.

object "YulContract" {}

The string literal at the top object declaration is the name of your contract. An object in Yul can contain a code block, data, and and sub objects. Inside of the YulContract object we have a code block and a sub object with the name runtime.

code {
    // ...
}object "runtime" {
    // ...
}

The runtime in this case is the contract code we want to deploy, while the code is what deploys our runtime. Inside of the code block we’ll first see a datacopy call.

datacopy(0, dataoffset("runtime"), datasize("runtime"))

These are not standard EVM opcodes, but rather part of the Yul Dialect (don’t worry, there aren’t many of these). The datacopy(destOffset, offset, size) opcode copies bytecode to memory where destOffset is the starting position in memory to copy to, offset is the starting position of the bytecode to copy, and size is the side of the bytecode to copy. In this case, the offset is set by the dataoffset opcode, which takes a string literal associated with an object, as does the datasize opcode. In this case, the object is runtime, which is where our contract logic is.

Next up, we have the runtime object with all of our juicy contract logic.
Value Checker

Since no functions are payable in this contract, we should revert if a caller tries to send Ether to this contract. We can do this by accessing the msg.value you may be familiar with in Solidity. This is accessible with the callvalue() opcode.

if iszero(iszero(callvalue())) {
    revert(0, 0)
}

Notice we have iszero(iszero(callvalue())).

Starting from the center, we get the callvalue(), which we check if it is zero with iszero().

The iszero(value) opcode returns 0x01 if the argument is zero, otherwise it returns 0x00. Remember the boolean type is just a byte abstraction where true == 1 and false == 0. Because of this, we can use iszero(iszero(value)) to invert the result. This means the following are functionally identical.

// solidity
if (msg.value != 0) {}// yul
if iszero(iszero(callvalue())) {}

So, if the call value is not zero, we should call revert(offset, size) where the offset is the starting position of the desired return data in memory and size is the size of the desired return data in memory. Since we don’t want to return any data, we set the offset and size both to zero.
Selector Switch

Now, on to the really cool part. When a contract is called, the 4 byte function selector is extracted and checked against all existing function selectors on the contract. Yul conveniently provides a switch statement for us to do this with.

switch extractSelector()// bytes4(keccak256("read()"))
case 0x57de26a4 {
    // read logic
}// bytes4(keccak256("set(uint256)"))
case 0x60fe47b1 {
    // write and event logic
}default {
    // fallback logic
}

Don’t worry about the extractSelector() in this section, this is a custom function to get the selector that I’ll break down momentarily. For now, just look at how the switch statement iterates through each function selector we have defined, and if none are found, we default to the fallback function. Whatever logic needs to be executed in each case will be in the respective block.

This bit is really beyond the scope of this article, but it’s worth mentioning the UUPS Proxy pattern relies on the fallback function to relay function calls to an underlying logic contract.

Next, we’re going to temporarily skim over the contents of the case blocks to read the helper functions.
Calldata Decoders

The first calldata decoder we define will be the extractSelector() function you saw in the switch statement.

function extractSelector() -> _selector {
    _selector := shr(0x28, calldataload(0))
}

This function will return a value called _selector so we indicate that by using the -> _selector syntax. Inside the function block, the innermost opcode is calldataload(offset) where offset is the starting position to load the next 32 bytes from the calldata. We specify 0 because the selector is always the first 4 bytes. Next is the shr(shift, value) which shifts a 32 byte value by the amount indicated by shift. We are shifting the first 32 bytes of calldata to the right by 28 bytes, discarding the rightmost 28 bytes, leaving only the 4 byte function selector.

// full calldata
0x60fe47b100000000000000000000000000000000000000000000000000000000000000001// first 32 bytes of calldata
0x60fe47b100000000000000000000000000000000000000000000000000000000// first 32 bytes of calldata shifted right 28 bytes
0x60fe47b1

The second calldata encoder takes an index or starting position of the desired parameter, and returns a 32 byte value, represented as a uint256 or a 32 byte value. In our case, there will never be more than one parameter in set(uint256), but this function is more modular and reusable.

function extractUint(index) -> _value {
    let position := add(4, mul(index, 0x20))
    if lt(calldatasize(), add(position, 0x20)) {
        revert(0, 0)
    }
    _value := calldataload(position)
}

We will be returning a _value which represents the first 32 byte parameter following the 4 byte selector from the calldata, and we declare the function as such with -> _value.

We use let to declare a new variable, position which will be the starting position of the parameter we want to extract. To compute this, let us again start in the innermost statement, the mul(a, b) multiplies a and b, which in this case is the index of the parameter and 0x20, or in human numbers, 32. The result of this is added with 4. Why? Because the first four bytes are the function selector, then each parameter after that consists of 32 bytes.

selectorOffset =    0            // 0
firstParamOffset =  4 + (0 * 32) // 4
secondParamOffset = 4 + (1 * 32) // 36
...

Next is another if statement. In this case, we check if the calldatasize() is less than add(position, 0x20), and if it is not, we revert with (0, 0). This check ensures the length of the calldata is long enough to extract a full 32 byte word from the parameter’s starting position.

Lastly, we use calldataload(position) to load the next 32 bytes of calldata into memory starting at position, also known as our newNumber parameter.
Return Value Encoder

We need to define a function that is designed to return a uint256 to the message caller, both for the read() function and the fallback() function. This is done with the return(offset, size) opcode where the offset is the starting position in memory of the desired return data and size is the number of bytes in memory of the desired return data. However, the data needs to first be stored in memory before reading it from memory.

function returnUint(value) {
    mstore(0, value)
    return(0, 0x20)
}

Since we’re returning an unsigned 256 bit integer, we store it starting at position 0 in memory, and it will occupy 32 bytes. To return the data from memory, we just need to specify the starting position, 0, and the ending position, 32 or 0x20. Easy peasy.
Storage Layout

In solidity, state variable slots are ordered by declaration order. Consider the following example Solidity contract.

contract MyCon {
    uint256 myNum;
    address myAddr;
}

The myNum variable is stored at slot 0 while myAddr is stored at slot 1. There are some optimizations that are done with values not occupying a full 256 bit word, like adjacent 8 bit integers, but that is beyond the scope of this article.

While we don’t declare state variables in such a straight forward way in Yul, we can create a set of functions that return the proper storage slot for a desired variable. In our contract, we have a single state variable, _myNumber, which if declared in a Solidity contract, would be stored at slot 0. We can specify this as follows.

function myNumberSlot() -> _slot {
    _slot := 0
}

This seems redundant, why not just hard-code the slot number wherever you need? This is because writing a pure function to return the slot value is more readable with minimal gas overhead.
Event Emitter

Briefly, before we dive into the event emitter, let us consider a few things. Solidity events can have 3 indexed parameters as “topics”. While other parameters are accessible in the event log, they are not topics. Consider the following.

event MyEvent(
    address indexed sender,
    address indexed receiver,
    uint256 indexed itemId,
    uint256 quantity
);

You would think this event has 3 topics because there are 3 indexed event parameters, but it actually has 4. This is because the first topic is a full keccak256 hash of the event signature, in this case the event signature is MyEvent(address,address,uint256,uint256).

This is important because in our example, we need to emit the hashed event signature, the address indexed setter parameter, but what do we do with the non-indexed parameters?

The EVM specifies 5 logging opcodes, log0, log1, log2, log3, and log4. Each of these takes an offset and size as its first two parameters, indicating starting position and size of the non-indexed return data in memory to log. Each log has a number of additional parameters that corresponds to their number.

log0(offset, size)
log1(offset, size, topic1)
log2(offset, size, topic1, topic2)
log3(offset, size, topic1, topic2, topic3)
log4(offset, size, topic1, topic2, topic3, topic4)

For our event, we need to use log2 where the first topic is the event signature, the second topic is the indexed setter address, and the memory offset and size needs to account for the uint256 oldNumber and uint256 newNumber, accounting for 64 bytes (or 0x40 bytes).

function emitMyNumberSet(setter, oldNumber, newNumber) {    // keccak256("MyNumberSet(address,uint256,uint256)")    let signatureHash := 0x29ad1af1374ae5de3c5b3f510eb08a7d10028e9dfe5aff6570c701c4177c76cb    mstore(0, oldNumber)    mstore(0x20, newNumber)    log2(0, 0x40, signatureHash, setter)}

Notice how before we call log2 and pass in memory parameters, we first store the oldNumber and newNumber in memory, at positions 0 and 32 respectively.
External

Okay, now that we have all the helpers out of the way, let us look at the actual function implementations.

We define a read() function that loads _myNumber from storage using our storage helper function.

function read() -> _myNumber {
    _myNumber := sload(myNumberSlot())
}

Such readable. Very code. Wow.

Remember, the sload(key) opcode takes a key and returns the value stored at that key, and since myNumberSlot() returns 0, we are loading _myNumber from slot 0.

Next, we define a set(newNumber) function to set a new value for _myNumber, then emit an event, MyNumberSet, with the setter address, the old number, and the new number.

function set(newNumber) {    let oldNumber := sload(myNumberSlot())    sstore(myNumberSlot(), newNumber)    emitMyNumberSet(caller(), oldNumber, newNumber)}

Sweet. So we load the old _myNumber value first, as we’ll need that for the event log. We do this with sload(myNumberSlot()) just as we did above. Next, we store the new value at the same slot with sstore(myNumberSlot(), newNumber). Finally, we emit the event with the function we defined above. We use caller() to get the message caller, or msg.sender in Solidity terms.
Selector Switch 2, Electric Boogaloo

Finally, we will revisit the case blocks in the function selector switch.

The first case represents our read function, and should return to the caller the _myNumber state variable.

case 0x57de26a4 {
    returnUint(read())
}

While our read() function does return _myNumber from it, we need to use our returnUint(value) function to actually return the value to the message caller.

The next case represents our set function, where we will need to extract the uint256 newNumber parameter encoded in the calldata, and pass it into our set(newNumber) function.

case 0x60fe47b1 {
    set(extractUint(0))
}

We pass 0 to our extractUint(index) function to indicate the newNumber parameter should be the first parameter encoded in the calldata.

Finally, we have the default or fallback function.

default {
    returnUint(42)
}

All we need to do is indicate we want to return a uint256 which, in our implementation, will always be 42, the answer to life, the universe, and everything.
Conclusion

Writing in Yul is no small task, just a simple read/write contract can be complex. Hopefully this shed some light on Yul, and promoted a stronger understanding of low level Solidity.

Good Hacking! 🤘
